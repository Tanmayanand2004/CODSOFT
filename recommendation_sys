# main.py
import pandas as pd
import json
import requests # Used for making API calls to the LLM
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# --- Mock LLM Function ---
# This function simulates the behavior of an LLM for demonstration purposes.
def get_llm_response(prompt):
    """
    Simulates a call to a Large Language Model API.
    """
    print("\n--- Sending Prompt to LLM (Simulation) ---")
    print(prompt)
    print("------------------------------------------\n")

    # In a real-world scenario, you would replace this with a call to an actual LLM API.
    # For this example, we'll just craft a nice string based on the prompt.
    if "Based on your interest in" in prompt:
        try:
            item_name = prompt.split("'")[1]
            recommendations_str = prompt.split(":")[-1].strip()
            recommendations = json.loads(recommendations_str.replace("'", '"'))
            
            response = f"Ah, a fan of '{item_name}'! Great choice. Based on that, you might also enjoy these: {', '.join(recommendations)}. "
            response += "Let me know if any of those catch your eye!"
            return response
        except (IndexError, json.JSONDecodeError):
            return "I have found some great recommendations for you! Enjoy."

    elif "For user" in prompt:
        try:
            user_id = prompt.split(" ")[2].replace(",", "")
            recommendations_str = prompt.split(":")[-1].strip()
            recommendations = json.loads(recommendations_str.replace("'", '"'))

            response = f"Welcome back, User {user_id}! Looking at what similar users have liked, I think you'll be interested in these: {', '.join(recommendations)}. "
            response += "Happy watching (or reading)!"
            return response
        except (IndexError, json.JSONDecodeError):
             return "Based on what similar users like, I've found some great recommendations for you! Enjoy."

    return "I have found some recommendations I think you will like!"

class RecommendationEngine:
    """
    A simple recommendation engine that implements both content-based and
    collaborative filtering techniques.
    """
    def __init__(self, content_data, ratings_data):
        self.content_data = content_data
        self.ratings_data = ratings_data
        self.content_similarity_matrix = self._build_content_similarity_matrix()
        self.user_item_matrix = self._build_user_item_matrix()

    def _build_content_similarity_matrix(self):
        tfidf_vectorizer = TfidfVectorizer(stop_words='english')
        tfidf_matrix = tfidf_vectorizer.fit_transform(self.content_data['features'])
        return cosine_similarity(tfidf_matrix, tfidf_matrix)

    def _build_user_item_matrix(self):
        user_item_matrix = self.ratings_data.pivot_table(index='user_id', columns='item_id', values='rating')
        return user_item_matrix.fillna(0)

    def get_content_based_recommendations(self, item_title, n_recommendations=3, use_llm=False):
        """
        Provides recommendations based on item content similarity.
        Returns a list of titles, a string from the LLM, or None if not found.
        """
        try:
            # Find rows where the title contains the user's input (case-insensitive)
            matched_rows = self.content_data[self.content_data['title'].str.lower().str.contains(item_title.lower())]
            
            if matched_rows.empty:
                return None # Return None if not found

            # Take the first match if there are multiple
            original_title = matched_rows['title'].iloc[0]
            item_idx = matched_rows.index[0]
            
        except IndexError:
            return None # Return None on error too

        similarity_scores = list(enumerate(self.content_similarity_matrix[item_idx]))
        similarity_scores = sorted(similarity_scores, key=lambda x: x[1], reverse=True)
        top_similar_items = similarity_scores[1:n_recommendations+1]
        recommended_item_indices = [i[0] for i in top_similar_items]
        recommended_titles = self.content_data['title'].iloc[recommended_item_indices].tolist()

        if use_llm:
            prompt = f"Based on your interest in '{original_title}', generate a friendly recommendation message for the following items: {recommended_titles}"
            return get_llm_response(prompt)
        
        return recommended_titles

    def get_collaborative_filtering_recommendations(self, user_id, n_recommendations=3, use_llm=False):
        if user_id not in self.user_item_matrix.index:
            return f"Sorry, User ID '{user_id}' was not found."
            
        user_similarity = cosine_similarity(self.user_item_matrix)
        user_similarity_df = pd.DataFrame(user_similarity, index=self.user_item_matrix.index, columns=self.user_item_matrix.index)
        user_similarity_scores = user_similarity_df[user_id]
        similar_users = user_similarity_scores.sort_values(ascending=False).index[1:]

        recommendations = {}
        for similar_user_id in similar_users:
            similar_user_ratings = self.user_item_matrix.loc[similar_user_id]
            unrated_items = self.user_item_matrix.loc[user_id][self.user_item_matrix.loc[user_id] == 0].index
            highly_rated_by_similar_user = similar_user_ratings[unrated_items][similar_user_ratings > 3]
            
            for item_id, rating in highly_rated_by_similar_user.items():
                if item_id not in recommendations:
                    recommendations[item_id] = 0
                recommendations[item_id] += rating * user_similarity_scores[similar_user_id]

        sorted_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)
        recommended_item_ids = [item[0] for item in sorted_recommendations[:n_recommendations]]
        recommended_titles = self.content_data[self.content_data['id'].isin(recommended_item_ids)]['title'].tolist()

        if use_llm:
            prompt = f"For user {user_id}, who has similar tastes to other users, generate a friendly recommendation message for the following items: {recommended_titles}"
            return get_llm_response(prompt)

        return recommended_titles

def parse_and_recommend(user_input, movie_engine, book_engine):
    """Parses user input and calls the appropriate recommendation method."""
    text = user_input.lower()
    
    engine = None
    engine_name = ""
    other_engine = None
    other_engine_name = ""

    if "movie" in text:
        engine = movie_engine
        engine_name = "movie"
        other_engine = book_engine
        other_engine_name = "book"
    elif "book" in text:
        engine = book_engine
        engine_name = "book"
        other_engine = movie_engine
        other_engine_name = "movie"
    else:
        return "I can recommend **movies** or **books**. Please specify which one you're interested in!"

    # Collaborative Filtering: e.g., "recommend movies for user 1"
    if "user" in text:
        try:
            parts = text.split()
            user_id_index = parts.index("user") + 1
            user_id = int(parts[user_id_index])
            return engine.get_collaborative_filtering_recommendations(user_id, use_llm=True)
        except (ValueError, IndexError):
            return "Please specify a valid user ID (e.g., '...for user 1')."

    # Content-Based Filtering: e.g., "recommend books like The Hobbit"
    elif "like" in text:
        try:
            title_start_index = text.find("like") + len("like")
            title = user_input[title_start_index:].strip().strip("'\"")
            
            if not title:
                return "Please tell me the title of the item you like!"

            # Try the requested engine first
            response = engine.get_content_based_recommendations(title, use_llm=True)
            
            if response is None:
                # If not found, check the other engine to be smarter
                other_response = other_engine.get_content_based_recommendations(title, use_llm=False)
                if other_response is not None:
                    return f"I couldn't find the {engine_name} '{title}', but I did find it as a {other_engine_name}. Would you like {other_engine_name} recommendations for it instead?"
                else:
                    return f"Sorry, the title '{title}' was not found in our database."
            
            return response
        except Exception:
            return "I couldn't quite understand that. Please use the format 'recommend books like <title>'."

    return "Sorry, I didn't understand. Try 'recommend movies for user 1' or 'recommend books like 1984'."

def start_chatbot():
    """Initializes the engines and runs the main chatbot loop."""
    # --- Load Movie Data ---
    movies_content = pd.DataFrame({
        'id': [1, 2, 3, 4, 5, 6],
        'title': ['The Shawshank Redemption', 'The Godfather', 'The Dark Knight', 'Pulp Fiction', 'Forrest Gump', 'Inception'],
        'features': ['drama prison escape', 'crime drama mafia', 'action crime drama thriller', 'crime drama', 'drama romance', 'action adventure sci-fi']
    })
    movies_ratings = pd.DataFrame({
        'user_id': [1, 1, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5],
        'item_id': [1, 2, 4, 1, 3, 2, 5, 3, 5, 6, 1, 6],
        'rating':  [5, 4, 3, 5, 4, 5, 4, 5, 3, 4, 4, 5]
    })
    movie_engine = RecommendationEngine(movies_content, movies_ratings)

    # --- Load Book Data ---
    books_content = pd.DataFrame({
        'id': [101, 102, 103, 104, 105, 106],
        'title': ['To Kill a Mockingbird', '1984', 'The Great Gatsby', 'The Catcher in the Rye', 'Pride and Prejudice', 'The Hobbit'],
        'features': ['classic fiction southern-gothic', 'dystopian classic social-science-fiction', 'classic fiction jazz-age', 'classic fiction coming-of-age', 'classic romance regency', 'fantasy adventure classic']
    })
    books_ratings = pd.DataFrame({
        'user_id': [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5],
        'item_id': [101, 103, 102, 106, 101, 104, 103, 105, 102, 105, 106],
        'rating':  [5, 4, 5, 3, 4, 5, 3, 5, 4, 4, 5]
    })
    book_engine = RecommendationEngine(books_content, books_ratings)

    # --- Start Chat Loop ---
    print("Welcome to the Recommendation Chatbot! 🤖")
    print("You can ask for recommendations. For example:")
    print("  - 'recommend movies for user 1'")
    print("  - 'recommend books like To Kill a Mockingbird'")
    print("\nType 'exit' or 'quit' to end the chat.")
    print("-" * 40)

    while True:
        user_input = input("You: ")
        if user_input.lower() in ["quit", "exit", "bye"]:
            print("Chatbot: Goodbye! 👋")
            break
        
        if not user_input:
            continue

        response = parse_and_recommend(user_input, movie_engine, book_engine)
        print(f"Chatbot: {response}")


if __name__ == '__main__':
    start_chatbot()
